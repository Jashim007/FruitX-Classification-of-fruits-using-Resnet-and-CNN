{"cells":[{"metadata":{"_uuid":"8f2839f25d086af736a60e9eeb907d3b93b6e0e5","_cell_guid":"b1076dfc-b9ad-4769-8c92-a6c4dae69d19","trusted":true},"cell_type":"code","source":"\nfrom sklearn.datasets import load_files\nimport numpy as np\n\ntrain_dir = '../input/fruits-1/Fruits_1/Training'\ntest_dir = '../input/fruits-1/Fruits_1/Test'\n\ndef load_dataset(path):\n    data = load_files(path)\n    files = np.array(data['filenames'])\n    targets = np.array(data['target'])\n    target_labels = np.array(data['target_names'])\n    return files,targets,target_labels\n    \nx_train, y_train,target_labels = load_dataset(train_dir)\nx_test, y_test,_ = load_dataset(test_dir)\nprint('Loading complete!')\n\nprint('Training set size : ' , x_train.shape[0])\nprint('Testing set size : ', x_test.shape[0])","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"target_labels","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"d629ff2d2480ee46fbb7e2d37f6b5fab8052498a","_cell_guid":"79c7e3d0-c299-4dcb-8224-4455121ee9b0","trusted":true},"cell_type":"code","source":"\nno_of_classes = len(np.unique(y_train))\nno_of_classes","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"print(y_train[0:10])\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from keras.utils import np_utils\ny_train = np_utils.to_categorical(y_train,no_of_classes)\ny_test = np_utils.to_categorical(y_test,no_of_classes)\ny_train[0]","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"x_test,x_valid = x_test[3500:],x_test[:3500]\ny_test,y_valid = y_test[3500:],y_test[:3500]\nprint('Vaildation X : ',x_valid.shape)\nprint('Vaildation y :',y_valid.shape)\nprint('Test X : ',x_test.shape)\nprint('Test y : ',y_test.shape)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"x_train[0]","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from keras.preprocessing.image import array_to_img, img_to_array, load_img\n\ndef convert_image_to_array(files):\n    images_as_array=[]\n    for file in files:\n        # Convert to Numpy Array\n        images_as_array.append(img_to_array(load_img(file)))\n    return images_as_array\n\nx_train = np.array(convert_image_to_array(x_train))\nprint('Training set shape : ',x_train.shape)\n\nx_valid = np.array(convert_image_to_array(x_valid))\nprint('Validation set shape : ',x_valid.shape)\n\nx_test = np.array(convert_image_to_array(x_test))\nprint('Test set shape : ',x_test.shape)\n\nprint('1st training image shape ',x_train[0].shape)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"x_train/=255\nx_valid/=255\nx_test/=255","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"x_train[0].shape","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"x_train[0].shape","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from keras.applications.resnet_v2 import ResNet50V2\nrs_model=ResNet50V2(include_top=False, weights='imagenet', input_tensor=None,input_shape=(100,100,3),classes=41)\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"model.summary()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"model = Sequential()\nmodel.add(rs_model)\nmodel.add(Dropout(0.2))\nmodel.add(Flatten())\nmodel.add(Dense(150))\nmodel.add(Activation('relu'))\nmodel.add(Dense(41,activation = 'softmax'))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from keras import backend as K\ndef recall(y_true, y_pred):\n     true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n     possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n     recall = true_positives / (possible_positives + K.epsilon())\n     return recall\n\ndef precision(y_true, y_pred):\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    precision = true_positives / (predicted_positives + K.epsilon())\n    return precision\nmodel.compile(loss='categorical_crossentropy',\n               optimizer='nadam',\n              metrics=['accuracy',recall,precision])\nprint('Compiled!')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"num_train_samples = len(x_train)\nnum_val_samples = len(x_valid)\ntrain_batch_size = 64\nval_batch_size = 64\ntrain_steps = np.ceil(num_train_samples / train_batch_size)\nval_steps = np.ceil(num_val_samples / val_batch_size)\nprint(train_steps)\n\nprint(val_steps)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"x_train.shape","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"y_train.shape","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"import tensorflow as tf\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D,MaxPooling2D\nfrom keras.layers import Activation, Dense, Flatten, Dropout\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import ModelCheckpoint\nfrom keras import backend as K\n\ntf.compat.v1.set_random_seed(0)\nnp.random.seed(0)\ncheckpointer = ModelCheckpoint(filepath = 'cnn_from_scratch_fruits.hdf5', verbose = 1, save_best_only = True,mode='max',monitor='val_accuracy')\n\n\ntrain_image_generator = ImageDataGenerator(rotation_range=45,width_shift_range=.15,height_shift_range=.15,horizontal_flip=True, zoom_range=0.3)\ntrain_data_gen = train_image_generator.flow(x_train,y_train)\n\n\n\n\n\nhistory=model.fit(train_data_gen,\n          steps_per_epoch=500, epochs=10,validation_data=(x_valid,y_valid),\n        callbacks = [checkpointer],\n                    verbose=2,shuffle=True)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"model.load_weights('cnn_from_scratch_fruits.hdf5')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"\nscore = model.evaluate(x_test, y_test, verbose=2)\nprint('\\n', 'Test accuracy:', score[1])\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"preds=np.round(model.predict(x_test),0)\nprint(\"Rounded test_labels\",preds)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# Let's visualize test prediction.\nimport matplotlib.pyplot as plt\n\ny_pred = model.predict(x_test)\n\n# plot a random sample of test images, their predicted labels, and ground truth\nfig = plt.figure(figsize=(16, 9))\nfor i, idx in enumerate(np.random.choice(x_test.shape[0], size=16, replace=False)):\n    ax = fig.add_subplot(4, 4, i + 1, xticks=[], yticks=[])\n    ax.imshow(np.squeeze(x_test[idx]))\n    pred_idx = np.argmax(y_pred[idx])\n    true_idx = np.argmax(y_test[idx])\n    ax.set_title(\"{} ({})\".format(target_labels[pred_idx], target_labels[true_idx]),\n                 color=(\"green\" if pred_idx == true_idx else \"red\"))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"import matplotlib.pyplot as plt\n# Plot training & validation accuracy values\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'],color='red')\nplt.title('Model accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper left')\nplt.show()\n\n# Plot training & validation loss values\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'],color='red')\nplt.title('Model loss')\nplt.ylabel('Loss')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Validation'], loc='upper left')\nplt.show()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from sklearn import metrics\nfrom sklearn.metrics import confusion_matrix\ncm=confusion_matrix(\n    y_test.argmax(axis=1), preds.argmax(axis=1))\ncm","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"cm.shape","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"import seaborn as sn\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf_cm = pd.DataFrame(cm, index = [i for i in ['Apple Braeburn', 'Apple Crimson Snow', 'Apple Golden 1',\n       'Apple Golden 2', 'Apple Golden 3', 'Apple Granny Smith',\n       'Apple Pink Lady', 'Apple Red 1', 'Apple Red 2', 'Apple Red 3',\n       'Apple Red Delicious', 'Apple Red Yellow 1', 'Apple Red Yellow 2',\n       'Banana', 'Banana Lady Finger', 'Banana Red', 'Cherry 1',\n       'Cherry 2', 'Cherry Rainier', 'Cherry Wax Black', 'Cherry Wax Red',\n       'Cherry Wax Yellow', 'Grape Blue', 'Grape Pink', 'Grape White',\n       'Grape White 2', 'Grape White 3', 'Grape White 4',\n       'Grapefruit Pink', 'Grapefruit White', 'Guava', 'Lychee', 'Mango',\n       'Mango Red', 'Orange', 'Pineapple', 'Pineapple Mini', 'Raspberry',\n       'Redcurrant', 'Strawberry', 'Strawberry Wedge']],\n                  columns = [i for i in ['Apple Braeburn', 'Apple Crimson Snow', 'Apple Golden 1',\n       'Apple Golden 2', 'Apple Golden 3', 'Apple Granny Smith',\n       'Apple Pink Lady', 'Apple Red 1', 'Apple Red 2', 'Apple Red 3',\n       'Apple Red Delicious', 'Apple Red Yellow 1', 'Apple Red Yellow 2',\n       'Banana', 'Banana Lady Finger', 'Banana Red', 'Cherry 1',\n       'Cherry 2', 'Cherry Rainier', 'Cherry Wax Black', 'Cherry Wax Red',\n       'Cherry Wax Yellow', 'Grape Blue', 'Grape Pink', 'Grape White',\n       'Grape White 2', 'Grape White 3', 'Grape White 4',\n       'Grapefruit Pink', 'Grapefruit White', 'Guava', 'Lychee', 'Mango',\n       'Mango Red', 'Orange', 'Pineapple', 'Pineapple Mini', 'Raspberry',\n       'Redcurrant', 'Strawberry', 'Strawberry Wedge']])\nplt.figure(figsize = (30,25))\nsn.heatmap(df_cm, annot=True)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from sklearn import metrics\nfrom sklearn.metrics import confusion_matrix\nclassification=metrics.classification_report(y_test,preds)\nprint(classification)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"from sklearn import metrics\nmetrics.roc_auc_score(y_test, preds,multi_class=\"ovr\",average='weighted')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"language":"python","display_name":"Python 3","name":"python3"},"language_info":{"pygments_lexer":"ipython3","nbconvert_exporter":"python","version":"3.6.4","file_extension":".py","codemirror_mode":{"name":"ipython","version":3},"name":"python","mimetype":"text/x-python"}},"nbformat":4,"nbformat_minor":4}